# ObscuraProto

Это документ, описывающий принципы работы гибридного протокола шифрования ObscuraProto **1.0**. В данной версии используется эллиптическая криптография, **ChaCha20-Poly1305** и механизм возобновления сессий.

## 1. Архитектура протокола

Протокол определяет два способа установления защищенного канала: полное рукопожатие (handshake) для новых соединений и сокращенное — для возобновления предыдущих сессий.

### Фаза 1: Полное установление соединения (Full Handshake с использованием ECC)

Эта фаза используется для первого подключения клиента к серверу и включает согласование версии протокола.

1.  **Инициация Клиента (Client Hello):**
    *   Клиент инициирует соединение, отправляя **список поддерживаемых версий протокола** (например, `[1.1, 1.0]`).
    *   Клиент генерирует свою эфемерную пару ключей ECDH и отправляет публичную часть на сервер.

2.  **Ответ и Аутентификация Сервера (Server Hello):**
    *   Сервер получает список версий и выбирает самую высокую из них, которую он также поддерживает. Если общие версии отсутствуют, сервер прерывает соединение. Вся дальнейшая коммуникация происходит по правилам выбранной версии.
    *   Сервер обладает долгосрочной парой ключей **Ed25519**. Его публичный ключ должен быть известен клиенту.
    *   Сервер генерирует свою эфемерную пару ключей **ECDH**.
    *   Сервер подписывает свой публичный ключ ECDH своим приватным ключом **Ed25519**.
    *   Сервер отправляет клиенту: **выбранную версию протокола**, свой публичный ключ ECDH и цифровую подпись.

3.  **Аутентификация Клиента и завершение обмена:**
    *   Клиент проверяет, что выбранная сервером версия входит в список поддерживаемых им.
    *   Клиент проверяет подпись публичного ключа ECDH с помощью публичного ключа **Ed25519** сервера.

4.  **Генерация общего секрета:**
    *   Клиент и сервер вычисляют общий секрет `S` по протоколу ECDH.
    *   Секрет `S` пропускается через **функцию деривации ключа (KDF)**, например, HKDF, для генерации **двух симметричных ключей** (один для отправки, один для приема) для шифра ChaCha20-Poly1305.

5.  **Создание билета сессии:** После успешного хендшейка сервер может создать **билет для возобновления сессии (Session Ticket)**. Этот билет содержит информацию о сессии, зашифрованную на ключе, известном только серверу, и отправляет его клиенту. В билет **обязательно включается информация о версии протокола**, на которой была установлена сессия.

### Фаза 2: Возобновление сессии (Session Resumption)

Если у клиента есть билет сессии, он может использовать сокращенный хендшейк.

1.  **Инициация Клиента:**
    *   Клиент подключается. **Если у клиента доступна более новая версия протокола, чем та, с которой был выдан билет сессии, или если билет сессии отсутствует/невалиден, клиент инициирует полное рукопожатие.**
    *   В противном случае (если билет валиден и клиент не имеет более новой версии протокола), клиент отправляет ранее полученный **билет сессии** для возобновления.
2.  **Проверка билета Сервером:**
    *   Сервер расшифровывает билет и извлекает из него **версию протокола** и мастер-ключ сессии.
    *   Сервер проверяет, что он все еще поддерживает версию протокола, указанную в билете. Если версия устарела и больше не поддерживается, сервер отказывает в возобновлении и может предложить клиенту пройти полное рукопожатие.
    *   Если версия поддерживается, сервер проверяет валидность билета (например, срок его действия) и извлекает мастер-ключ.
3.  **Начало передачи данных:** Стороны пропускают асимметричную криптографию и сразу переходят к защищенной передаче данных, используя ключи, сгенерированные на основе мастер-ключа сессии.

### Фаза 3: Передача данных

1.  Данные шифруются с использованием современного **AEAD-шифра (Authenticated Encryption with Associated Data) ChaCha20-Poly1305**. Этот шифр объединяет шифрование и аутентификацию в одной операции.
2.  Для каждого сообщения генерируется уникальный **Nonce** (number used once) размером 12 байт, который передается в открытом виде.
3.  **Защита целостности и аутентичности:** Шифр ChaCha20-Poly1305 автоматически вычисляет **аутентификационный тег (Authentication Tag)**. Этот тег защищает от модификации и подделки как зашифрованные данные, так и "дополнительные аутентифицируемые данные" (Associated Data), которыми в нашем случае является счетчик сообщений.
4.  Итоговое сообщение для отправки выглядит так: `Nonce + Счетчик + Шифротекст + Auth Tag`.

## 2. Формат передаваемых данных

Формат делится на два уровня: **конверт шифрования**, который обеспечивает безопасность, и **полезная нагрузка (payload)**, которая содержит сами данные приложения.

### 2.1. Структура конверта шифрования

Каждое сообщение, передаваемое по защищенному каналу, оборачивается в следующий "конверт":

`[Nonce (12 байт)] + [Счетчик (8 байт)] + [Зашифрованные данные (переменная длина)] + [Auth Tag (16 байт)]`

1.  **Nonce (Number used once)**
    *   **Длина:** 12 байт. Генерируется для каждого сообщения.
    *   **Назначение:** Уникальное для каждого сообщения число, необходимое для корректной и безопасной работы шифра ChaCha20.

2.  **Счетчик сообщений (Message Counter)**
    *   **Длина:** 8 байт.
    *   **Назначение:** Защита от атак повторного воспроизведения (replay attacks). Это поле не шифруется, но его целостность защищается аутентификационным тегом.

3.  **Зашифрованные данные (Шифротекст)**
    *   **Содержимое:** Исходная полезная нагрузка (payload), зашифрованная с помощью ChaCha20.

4.  **Auth Tag (Authentication Tag)**
    *   **Длина:** 16 байт (для Poly1305).
    *   **Назначение:** Обеспечивает целостность и аутентичность `Nonce`, `Счетчика` и `шифротекста`. Вычисляется автоматически в процессе шифрования.

### 2.2. Структура полезной нагрузки (Payload)

Данные, которые помещаются в поле `Зашифрованные данные` (до момента шифрования), должны иметь следующую бинарную структуру:

`[Код операции (2 байта)] + [Параметры операции (N байт)]`

*   **Код операции**: 2-байтное целое число (в сетевом порядке байт, Big-Endian), которое однозначно определяет тип запроса или сообщения. Например, `0x1001` для запроса на аутентификацию.
*   **Параметры операции**: Данные, необходимые для выполнения операции, сериализованные с использованием **метода префикса с длиной**.

#### Метод сериализации "Префикс с длиной"

Каждый параметр в `Параметрах операции` кодируется по схеме "длина-значение":

`[Длина поля (2 байта)] + [Значение поля (N байт)]`

**Пример: Полезная нагрузка для операции "Логин" (`0x1001`)**

Предположим, операция требует `username` (строка) и `password` (строка).
*   `username`: "test" (4 байта)
*   `password`: "p@ss" (4 байта)

Итоговая полезная нагрузка (payload) до шифрования будет выглядеть так:

1.  `0x10, 0x01` — Код операции "Логин"
2.  `0x00, 0x04` — Длина `username`
3.  `0x74, 0x65, 0x73, 0x74` — байты "test"
4.  `0x00, 0x04` — Длина `password`
5.  `0x70, 0x40, 0x73, 0x73` — байты "p@ss"

Именно эта последовательность байт и будет зашифрована и помещена в поле `Зашифрованные данные`.

### Алгоритм отправки сообщения

1.  **Сформировать полезную нагрузку:** Собрать `Код операции` и `Параметры` в единый байтовый массив согласно бинарной структуре.
2.  **Инкрементировать счетчик:** Увеличить на 1 значение своего счетчика отправленных сообщений.
3.  **Сгенерировать Nonce:** Создать криптографически случайный 12-байтный Nonce.
4.  **Зашифровать и аутентифицировать:** Выполнить операцию шифрования ChaCha20-Poly1305.
    *   **Входные данные:** сессионный ключ, Nonce, полезная нагрузка (как открытый текст), и `Счетчик` (как "associated data").
    *   **Выходные данные:** `шифротекст` и 16-байтный `Auth Tag`.
5.  **Отправить:** Собрать и отправить итоговое сообщение: `Nonce + Счетчик + шифротекст + Auth Tag`.

### Алгоритм получения и проверки сообщения

1.  **Разделить сообщение:** Полученное сообщение делится на `Nonce`, `Счетчик`, `шифротекст` и `Auth Tag`.
2.  **Проверить и расшифровать:** Выполнить операцию расшифровки ChaCha20-Poly1305.
    *   **Входные данные:** сессионный ключ, `Nonce`, `шифротекст`, `Auth Tag` и `Счетчик` (как "associated data").
    *   Эта операция автоматически проверяет `Auth Tag`. Если тег невалиден, операция завершится ошибкой, и сообщение должно быть **немедленно отброшено**.
3.  **Проверить счетчик:** Если расшифровка прошла успешно, сравнить значение счетчика с ожидаемым. Если он меньше или равен последнему полученному, отбросить сообщение как повтор.
4.  **Распарсить полезную нагрузку:**
    *   Прочитать первые 2 байта расшифрованных данных, чтобы определить **Код операции**.
    *   В зависимости от кода операции, последовательно распарсить оставшуюся часть данных, используя метод префикса с длиной, чтобы извлечь все параметры.
5.  **Обновить счетчик** и передать данные на обработку в логику приложения.

Этот алгоритм обеспечивает надежную защиту передаваемых данных в рамках протокола ObscuraProto.

## 3. Анализ надежности

*   **Совершенная прямая секретность (PFS):** Сохраняется благодаря эфемерным ключам ECDH.
*   **Производительность:** ECC обеспечивает высокую скорость асимметричных операций. ChaCha20-Poly1305 является очень быстрым симметричным шифром. Возобновление сессий ускоряет повторные подключения.
*   **Модель доверия:** Протокол предполагает, что клиент заранее доверяет публичному ключу Ed25519 сервера.

## 4. Ключевые решения

*   **ChaCha20-Poly1305:** Современный высокопроизводительный AEAD-шифр, обеспечивающий одновременно конфиденциальность и целостность данных.
*   **Эллиптическая криптография (ECC):** Основа асимметричных операций, обеспечивающая баланс скорости и безопасности, в частности, с использованием Ed25519 для подписей и X25519 для обмена ключами.
*   **Функция деривации ключа (KDF):** Критически важный компонент для генерации двух различных ключей (для отправки и приема) из общего секрета.
*   **Защита от Replay-атак:** Реализована с помощью счетчика сообщений, который включен в состав каждого сообщения и **аутентифицируется с помощью Poly1305**. Это предотвращает повторное воспроизведение старых сообщений.

## 5. Основы использования API

> **Внимание:** Далее описывается низкоуровневый API ("bare metal") библиотеки ObscuraProto. Этот API предназначен для построения более высокоуровневых абстракций и не рекомендуется для прямого использования в большинстве приложений, так как требует аккуратного управления состоянием.

Библиотека предоставляет класс `Session`, который инкапсулирует логику для одного клиентского или серверного соединения. Полный жизненный цикл продемонстрирован в `examples/basic_encryption_example.cpp`.

### Шаг 1: Инициализация

Прежде всего, необходимо инициализировать криптографическую библиотеку (libsodium). Это нужно сделать один раз при запуске вашего приложения.

```cpp
#include "obscuraproto/crypto.hpp"

if (ObscuraProto::Crypto::init() != 0) {
    // Обработка сбоя инициализации
}
```

### Шаг 2: Настройка ключей

Серверу необходима долгосрочная пара ключей Ed25519 для подписи своих сообщений при рукопожатии. Клиент должен заранее знать публичный ключ подписи сервера, чтобы проверить его подлинность.

```cpp
// На сервере: генерируем долгосрочный ключ
auto server_long_term_key = ObscuraProto::Crypto::generate_sign_keypair();

// На клиенте: настраиваем публичный ключ сервера
ObscuraProto::KeyPair client_view_of_server_key;
client_view_of_server_key.publicKey = server_long_term_key.publicKey; // Этот ключ должен быть безопасно доставлен клиенту
```

### Шаг 3: Создание сессий

Создайте объекты `Session` как для клиента, так и для сервера.

```cpp
#include "obscuraproto/session.hpp"

// На стороне сервера
ObscuraProto::Session server_session(ObscuraProto::Role::SERVER, server_long_term_key);

// На стороне клиента
ObscuraProto::Session client_session(ObscuraProto::Role::CLIENT, client_view_of_server_key);
```

### Шаг 4: Рукопожатие (Handshake)

Рукопожатие — это трехэтапный процесс, включающий обмен эфемерными ключами и подписями.

1.  **Инициация клиента:** Клиент генерирует эфемерный ключ и отправляет сообщение `ClientHello`.
    ```cpp
    // Клиент отправляет это серверу
    auto client_hello = client_session.client_initiate_handshake();
    ```

2.  **Ответ сервера:** Сервер получает `ClientHello`, проверяет его, генерирует свой эфемерный ключ, подписывает его и вычисляет общие сессионные ключи. Затем он отправляет обратно `ServerHello`.
    ```cpp
    // Сервер получает client_hello и отправляет это в ответ
    auto server_hello = server_session.server_respond_to_handshake(client_hello);
    // Рукопожатие на стороне сервера завершено
    assert(server_session.is_handshake_complete());
    ```

3.  **Завершение на клиенте:** Клиент получает `ServerHello`, проверяет подпись сервера и вычисляет те же самые общие сессионные ключи.
    ```cpp
    // Клиент получает server_hello
    client_session.client_finalize_handshake(server_hello);
    // Рукопожатие на стороне клиента завершено
    assert(client_session.is_handshake_complete());
    ```
На этом этапе у обеих сторон есть защищенный канал.

### Шаг 5: Передача данных

Для отправки данных необходимо сначала сконструировать `Payload`.

1.  **Создание и шифрование полезной нагрузки:**
    ```cpp
    #include "obscuraproto/packet.hpp"

    // На клиенте
    ObscuraProto::Payload client_payload;
    client_payload.op_code = 0x1001; // Ваш специфичный для приложения код операции
    client_payload.add_param("my_username");
    client_payload.add_param("my_secret_password");

    // Шифруем полезную нагрузку, чтобы получить пакет, готовый к передаче
    ObscuraProto::EncryptedPacket packet_to_send = client_session.encrypt_payload(client_payload);
    ```
    Полученный `packet_to_send` — это `std::vector<uint8_t>`, который можно отправлять по любому сетевому транспорту (TCP, UDP и т.д.).

2.  **Получение и расшифровка пакета:**
    ```cpp
    // На сервере, после получения packet_to_send
    try {
        ObscuraProto::Payload decrypted_payload = server_session.decrypt_packet(packet_to_send);

        // Разбираем параметры
        ObscuraProto::Payload::ParamParser parser(decrypted_payload.parameters);
        std::string username, password;
        parser.next_param(username);
        parser.next_param(password);
        
        // Используем данные...

    } catch (const ObscuraProto::RuntimeError& e) {
        // Ошибка расшифровки (например, неверный тег, replay-атака)
        // Сообщение должно быть отброшено.
    }
    ```

## 6. Высокоуровневый API (WebSocket)

Для большинства сценариев использования рекомендуется применять высокоуровневые обертки для WebSocket, которые автоматически управляют всеми сложностями сетевого взаимодействия, управления соединениями и процессом рукопожатия.

Полный пример можно найти в файле `examples/websocket_example.cpp`.

### Шаг 1: Инициализация и настройка ключей

Этот шаг аналогичен низкоуровневому API. Вам необходимо инициализировать криптографическую библиотеку и настроить ключи сервера.

```cpp
#include "obscuraproto/crypto.hpp"

// Инициализируем libsodium
ObscuraProto::Crypto::init();

// На сервере: генерируем долгосрочный ключ
auto server_long_term_key = ObscuraProto::Crypto::generate_sign_keypair();

// На клиенте: настраиваем публичный ключ сервера
ObscuraProto::KeyPair client_view_of_server_key;
client_view_of_server_key.publicKey = server_long_term_key.publicKey;
```

### Шаг 2: Запуск сервера

Создайте `WsServerWrapper`, установите функцию обратного вызова для обработки входящих данных и запустите его на порту.

```cpp
#include "obscuraproto/ws_server.hpp"

// Создаем сервер
ObscuraProto::net::WsServerWrapper server(server_long_term_key);

// Устанавливаем callback для обработки полученных данных и отправки ответа
server.set_on_payload_callback([&server](auto hdl, ObscuraProto::Payload payload) {
    std::cout << "[SERVER] Получена полезная нагрузка." << std::endl;
    
    // Создаем и отправляем ответ
    ObscuraProto::Payload response_payload;
    response_payload.op_code = 0x2002;
    response_payload.add_param("Привет от сервера!");
    server.send(hdl, response_payload);
});

// Запускаем сервер на порту 9002
server.run(9002);
```

### Шаг 3: Запуск клиента

Создайте `WsClientWrapper`, установите функции обратного вызова для событий и подключитесь к серверу.

```cpp
#include "obscuraproto/ws_client.hpp"

// Создаем клиент
ObscuraProto::net::WsClientWrapper client(client_view_of_server_key);

// Устанавливаем callback на момент, когда защищенный канал будет готов
client.set_on_ready_callback([&client]() {
    std::cout << "[CLIENT] Рукопожатие завершено. Отправка сообщения..." << std::endl;
    ObscuraProto::Payload client_payload;
    client_payload.op_code = 0x1001;
    client_payload.add_param("my_username");
    client.send(client_payload);
});

// Устанавливаем callback для обработки данных от сервера
client.set_on_payload_callback([](ObscuraProto::Payload payload) {
    std::cout << "[CLIENT] Получен ответ от сервера." << std::endl;
});

// Подключаемся к серверу
client.connect("ws://localhost:9002");

// ... ждем выполнения работы ...

// Отключаемся по завершении
client.disconnect();
server.stop();
```

### Зависимости

Эта библиотека требует **libsodium**, **websocketpp** и **asio**. Если вы используете CMake, они будут автоматически загружены и настроены с помощью `FetchContent`. Вам нужно только слинковать вашу цель с `obscuraproto`.

```cmake
target_link_libraries(your_executable_name
    PRIVATE
        obscuraproto
)
```
