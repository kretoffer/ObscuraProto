# ObscuraProto

Это документ, описывающий принципы работы гибридного протокола шифрования ObscuraProto **1.0**. В данной версии используется эллиптическая криптография, **ChaCha20-Poly1305** и механизм возобновления сессий.

## 1. Архитектура протокола

Протокол определяет два способа установления защищенного канала: полное рукопожатие (handshake) для новых соединений и сокращенное — для возобновления предыдущих сессий.

### Фаза 1: Полное установление соединения (Full Handshake с использованием ECC)

Эта фаза используется для первого подключения клиента к серверу и включает согласование версии протокола.

1.  **Инициация Клиента (Client Hello):**
    *   Клиент инициирует соединение, отправляя **список поддерживаемых версий протокола** (например, `[1.1, 1.0]`).
    *   Клиент генерирует свою эфемерную пару ключей ECDH и отправляет публичную часть на сервер.

2.  **Ответ и Аутентификация Сервера (Server Hello):**
    *   Сервер получает список версий и выбирает самую высокую из них, которую он также поддерживает. Если общие версии отсутствуют, сервер прерывает соединение. Вся дальнейшая коммуникация происходит по правилам выбранной версии.
    *   Сервер обладает долгосрочной парой ключей **Ed25519**. Его публичный ключ должен быть известен клиенту.
    *   Сервер генерирует свою эфемерную пару ключей **ECDH**.
    *   Сервер подписывает свой публичный ключ ECDH своим приватным ключом **Ed25519**.
    *   Сервер отправляет клиенту: **выбранную версию протокола**, свой публичный ключ ECDH и цифровую подпись.

3.  **Аутентификация Клиента и завершение обмена:**
    *   Клиент проверяет, что выбранная сервером версия входит в список поддерживаемых им.
    *   Клиент проверяет подпись публичного ключа ECDH с помощью публичного ключа **Ed25519** сервера.

4.  **Генерация общего секрета:**
    *   Клиент и сервер вычисляют общий секрет `S` по протоколу ECDH.
    *   Секрет `S` пропускается через **функцию деривации ключа (KDF)**, например, HKDF, для генерации **двух симметричных ключей** (один для отправки, один для приема) для шифра ChaCha20-Poly1305.

5.  **Создание билета сессии:** После успешного хендшейка сервер может создать **билет для возобновления сессии (Session Ticket)**. Этот билет содержит информацию о сессии, зашифрованную на ключе, известном только серверу, и отправляет его клиенту. В билет **обязательно включается информация о версии протокола**, на которой была установлена сессия.

### Фаза 2: Возобновление сессии (Session Resumption)

Если у клиента есть билет сессии, он может использовать сокращенный хендшейк.

1.  **Инициация Клиента:**
    *   Клиент подключается. **Если у клиента доступна более новая версия протокола, чем та, с которой был выдан билет сессии, или если билет сессии отсутствует/невалиден, клиент инициирует полное рукопожатие.**
    *   В противном случае (если билет валиден и клиент не имеет более новой версии протокола), клиент отправляет ранее полученный **билет сессии** для возобновления.
2.  **Проверка билета Сервером:**
    *   Сервер расшифровывает билет и извлекает из него **версию протокола** и мастер-ключ сессии.
    *   Сервер проверяет, что он все еще поддерживает версию протокола, указанную в билете. Если версия устарела и больше не поддерживается, сервер отказывает в возобновлении и может предложить клиенту пройти полное рукопожатие.
    *   Если версия поддерживается, сервер проверяет валидность билета (например, срок его действия) и извлекает мастер-ключ.
3.  **Начало передачи данных:** Стороны пропускают асимметричную криптографию и сразу переходят к защищенной передаче данных, используя ключи, сгенерированные на основе мастер-ключа сессии.

### Фаза 3: Передача данных

1.  Данные шифруются с использованием современного **AEAD-шифра (Authenticated Encryption with Associated Data) ChaCha20-Poly1305**. Этот шифр объединяет шифрование и аутентификацию в одной операции.
2.  Для каждого сообщения генерируется уникальный **Nonce** (number used once) размером 12 байт, который передается в открытом виде.
3.  **Защита целостности и аутентичности:** Шифр ChaCha20-Poly1305 автоматически вычисляет **аутентификационный тег (Authentication Tag)**. Этот тег защищает от модификации и подделки как зашифрованные данные, так и "дополнительные аутентифицируемые данные" (Associated Data), которыми в нашем случае является счетчик сообщений.
4.  Итоговое сообщение для отправки выглядит так: `Nonce + Счетчик + Шифротекст + Auth Tag`.

## 2. Формат передаваемых данных

Формат делится на два уровня: **конверт шифрования**, который обеспечивает безопасность, и **полезная нагрузка (payload)**, которая содержит сами данные приложения.

### 2.1. Структура конверта шифрования

Каждое сообщение, передаваемое по защищенному каналу, оборачивается в следующий "конверт":

`[Nonce (12 байт)] + [Счетчик (8 байт)] + [Зашифрованные данные (переменная длина)] + [Auth Tag (16 байт)]`

1.  **Nonce (Number used once)**
    *   **Длина:** 12 байт. Генерируется для каждого сообщения.
    *   **Назначение:** Уникальное для каждого сообщения число, необходимое для корректной и безопасной работы шифра ChaCha20.

2.  **Счетчик сообщений (Message Counter)**
    *   **Длина:** 8 байт.
    *   **Назначение:** Защита от атак повторного воспроизведения (replay attacks). Это поле не шифруется, но его целостность защищается аутентификационным тегом.

3.  **Зашифрованные данные (Шифротекст)**
    *   **Содержимое:** Исходная полезная нагрузка (payload), зашифрованная с помощью ChaCha20.

4.  **Auth Tag (Authentication Tag)**
    *   **Длина:** 16 байт (для Poly1305).
    *   **Назначение:** Обеспечивает целостность и аутентичность `Nonce`, `Счетчика` и `шифротекста`. Вычисляется автоматически в процессе шифрования.

### 2.2. Структура полезной нагрузки (Payload)

Данные, которые помещаются в поле `Зашифрованные данные` (до момента шифрования), должны иметь следующую бинарную структуру:

`[Код операции (2 байта)] + [Параметры операции (N байт)]`

*   **Код операции**: 2-байтное целое число (в сетевом порядке байт, Big-Endian), которое однозначно определяет тип запроса или сообщения. Например, `0x1001` для запроса на аутентификацию.
*   **Параметры операции**: Данные, необходимые для выполнения операции, сериализованные с использованием **метода префикса с длиной**.

#### Метод сериализации "Префикс с длиной"

Каждый параметр в `Параметрах операции` кодируется по схеме "длина-значение":

`[Длина поля (2 байта)] + [Значение поля (N байт)]`

**Пример: Полезная нагрузка для операции "Логин" (`0x1001`)**

Предположим, операция требует `username` (строка) и `password` (строка).
*   `username`: "test" (4 байта)
*   `password`: "p@ss" (4 байта)

Итоговая полезная нагрузка (payload) до шифрования будет выглядеть так:

1.  `0x10, 0x01` — Код операции "Логин"
2.  `0x00, 0x04` — Длина `username`
3.  `0x74, 0x65, 0x73, 0x74` — байты "test"
4.  `0x00, 0x04` — Длина `password`
5.  `0x70, 0x40, 0x73, 0x73` — байты "p@ss"

Именно эта последовательность байт и будет зашифрована и помещена в поле `Зашифрованные данные`.

### Алгоритм отправки сообщения

1.  **Сформировать полезную нагрузку:** Собрать `Код операции` и `Параметры` в единый байтовый массив согласно бинарной структуре.
2.  **Инкрементировать счетчик:** Увеличить на 1 значение своего счетчика отправленных сообщений.
3.  **Сгенерировать Nonce:** Создать криптографически случайный 12-байтный Nonce.
4.  **Зашифровать и аутентифицировать:** Выполнить операцию шифрования ChaCha20-Poly1305.
    *   **Входные данные:** сессионный ключ, Nonce, полезная нагрузка (как открытый текст), и `Счетчик` (как "associated data").
    *   **Выходные данные:** `шифротекст` и 16-байтный `Auth Tag`.
5.  **Отправить:** Собрать и отправить итоговое сообщение: `Nonce + Счетчик + шифротекст + Auth Tag`.

### Алгоритм получения и проверки сообщения

1.  **Разделить сообщение:** Полученное сообщение делится на `Nonce`, `Счетчик`, `шифротекст` и `Auth Tag`.
2.  **Проверить и расшифровать:** Выполнить операцию расшифровки ChaCha20-Poly1305.
    *   **Входные данные:** сессионный ключ, `Nonce`, `шифротекст`, `Auth Tag` и `Счетчик` (как "associated data").
    *   Эта операция автоматически проверяет `Auth Tag`. Если тег невалиден, операция завершится ошибкой, и сообщение должно быть **немедленно отброшено**.
3.  **Проверить счетчик:** Если расшифровка прошла успешно, сравнить значение счетчика с ожидаемым. Если он меньше или равен последнему полученному, отбросить сообщение как повтор.
4.  **Распарсить полезную нагрузку:**
    *   Прочитать первые 2 байта расшифрованных данных, чтобы определить **Код операции**.
    *   В зависимости от кода операции, последовательно распарсить оставшуюся часть данных, используя метод префикса с длиной, чтобы извлечь все параметры.
5.  **Обновить счетчик** и передать данные на обработку в логику приложения.

Этот алгоритм обеспечивает надежную защиту передаваемых данных в рамках протокола ObscuraProto.

## 3. Анализ надежности

*   **Совершенная прямая секретность (PFS):** Сохраняется благодаря эфемерным ключам ECDH.
*   **Производительность:** ECC обеспечивает высокую скорость асимметричных операций. ChaCha20-Poly1305 является очень быстрым симметричным шифром. Возобновление сессий ускоряет повторные подключения.
*   **Модель доверия:** Протокол предполагает, что клиент заранее доверяет публичному ключу Ed25519 сервера.

## 4. Ключевые решения

*   **ChaCha20-Poly1305:** Современный высокопроизводительный AEAD-шифр, обеспечивающий одновременно конфиденциальность и целостность данных.
*   **Эллиптическая криптография (ECC):** Основа асимметричных операций, обеспечивающая баланс скорости и безопасности, в частности, с использованием Ed25519 для подписей и X25519 для обмена ключами.
*   **Функция деривации ключа (KDF):** Критически важный компонент для генерации двух различных ключей (для отправки и приема) из общего секрета.
*   **Защита от Replay-атак:** Реализована с помощью счетчика сообщений, который включен в состав каждого сообщения и **аутентифицируется с помощью Poly1305**. Это предотвращает повторное воспроизведение старых сообщений.
