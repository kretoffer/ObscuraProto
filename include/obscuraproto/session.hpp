#ifndef OBSCURAPROTO_SESSION_HPP
#define OBSCURAPROTO_SESSION_HPP

#include "crypto.hpp"
#include "packet.hpp"
#include "version.hpp"

#include <memory>

namespace ObscuraProto {

    enum class Role {
        CLIENT,
        SERVER
    };

    /**
     * @brief Manages the state and logic for a single ObscuraProto session.
     */
    class Session {
    public:
        /**
         * @brief Construct a new Session object.
         * @param role Whether this session belongs to a client or a server.
         * @param server_sign_key For a server, its long-term signing key pair.
         *                        For a client, a key pair with only the public key part filled.
         */
        Session(Role role, KeyPair server_sign_key);

        // Handshake-related data structures
        struct ClientHello {
            std::vector<Version> supported_versions;
            byte_vector kx_packet; // The packet generated by hydro_kx_n_1
        };

        /**
         * @brief [CLIENT] Initiates a full handshake. This completes the key exchange for the client.
         * @return A ClientHello message to be sent to the server.
         */
        ClientHello client_initiate_handshake();

        /**
         * @brief [SERVER] Handles a ClientHello and completes the key exchange for the server.
         * @param client_hello The message received from the client.
         * @throws std::runtime_error if no compatible version is found.
         */
        void server_respond_to_handshake(const ClientHello& client_hello);

        /**
         * @brief Encrypts a payload to be sent over the secure channel.
         * @param payload The application data to send.
         * @return An encrypted packet ready for transport.
         */
        EncryptedPacket encrypt_payload(const Payload& payload);

        /**
         * @brief Decrypts a received packet.
         * @param packet The packet received from the transport.
         * @return The decrypted application payload.
         * @throws std::runtime_error on decryption or counter failure.
         */
        Payload decrypt_packet(const EncryptedPacket& packet);

        /**
         * @brief Checks if the handshake has been successfully completed.
         */
        bool is_handshake_complete() const;

    private:
        Role role_;
        bool handshake_complete_ = false;

        // Long-term keys. For the 'N' pattern, this MUST be a kx keypair.
        KeyPair server_static_key_; // Server's private key is only present on the server.

        // Session keys (derived from ECDH)
        std::unique_ptr<Crypto::SessionKeys> session_keys_;

        // Message counters
        uint64_t send_counter_ = 0;
        uint64_t recv_counter_ = 0;
    };

} // namespace ObscuraProto

#endif // OBSCURAPROTO_SESSION_HPP
