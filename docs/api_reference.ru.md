# Справочник по API ObscuraProto

Этот документ предоставляет детальное описание каждого публичного компонента библиотеки ObscuraProto.

---

## `errors.hpp`

Определяет иерархию исключений, используемых в библиотеке.

### `class ObscuraProto::Exception`
Базовый класс для всех исключений библиотеки. Наследуется от `std::exception`.

#### `virtual const char* what() const noexcept override`
Возвращает сообщение об ошибке.

---

### `class ObscuraProto::RuntimeError`
Исключение, выбрасываемое при ошибках времени выполнения.
- **Примеры:** сбой расшифровки, неверная подпись, ошибка обмена ключами.

---

### `class ObscuraProto::LogicError`
Исключение, указывающее на некорректное использование API.
- **Примеры:** попытка зашифровать данные до завершения рукопожатия, вызов метода, предназначенного только для сервера, на стороне клиента.

---

### `class ObscuraProto::InvalidArgument`
Исключение, выбрасываемое при передаче некорректных аргументов в функцию. Наследуется от `LogicError`.
- **Примеры:** передача ключа неверного размера.

---

## `keys.hpp`

Определяет базовые структуры для хранения криптографических ключей и подписей.

### `struct ObscuraProto::PublicKey`
Представляет публичный ключ.
- `std::vector<uint8_t> data`: Сырые байты ключа.

### `struct ObscuraProto::PrivateKey`
Представляет приватный ключ.
- `std::vector<uint8_t> data`: Сырые байты ключа.

### `struct ObscuraProto::KeyPair`
Представляет пару, состоящую из публичного и приватного ключей.
- `PublicKey publicKey`: Публичный ключ.
- `PrivateKey privateKey`: Приватный ключ.

### `struct ObscuraProto::Signature`
Представляет цифровую подпись.
- `std::vector<uint8_t> data`: Сырые байты подписи.

---

## `version.hpp`

Определяет константы и типы для управления версией протокола.

### `using Version = uint16_t`
Псевдоним для типа версии протокола. Версия `1.0` представляется как `0x0100`.

### `const std::vector<Version> SUPPORTED_VERSIONS`
Список версий протокола, поддерживаемых текущей версией библиотеки.

---

## `packet.hpp`

Определяет структуру полезной нагрузки (`Payload`) до шифрования и после расшифровки.

### `using byte_vector = std::vector<uint8_t>`
Псевдоним для представления массива байт.

### `using EncryptedPacket = byte_vector`
Псевдоним для зашифрованного пакета. Его содержимое непрозрачно и готово к передаче по сети.

### `class ObscuraProto::Payload`
Класс для конструирования полезной нагрузки.

- `OpCode op_code`: 16-битный код операции, определяющий тип сообщения.
- `byte_vector parameters`: Сериализованные параметры для данной операции.

#### `void add_param(const byte_vector& param)`
Добавляет параметр в виде массива байт. Использует сериализацию с префиксом длины (2 байта длины + N байт данных).

#### `void add_param(const std::string& param)`
Добавляет строковый параметр.

#### `byte_vector serialize() const`
Сериализует весь объект `Payload` (код операции + параметры) в единый массив байт, готовый к шифрованию.

#### `static Payload deserialize(const byte_vector& data)`
Десериализует массив байт обратно в объект `Payload`.
- **Выбрасывает:** `RuntimeError`, если данные повреждены или их размер недостаточен.

---

### `class ObscuraProto::Payload::ParamParser`
Вспомогательный класс для последовательного извлечения параметров из `Payload`.

#### `explicit ParamParser(const byte_vector& params)`
Конструктор, принимающий поле `parameters` из объекта `Payload`.

#### `bool next_param(byte_vector& out_param)`
Извлекает следующий параметр в `out_param`. Возвращает `true` в случае успеха.

#### `bool next_param(std::string& out_param)`
Извлекает следующий параметр в виде строки. Возвращает `true` в случае успеха.

---

## `crypto.hpp`

Статический класс, предоставляющий все низкоуровневые криптографические функции.

### `static int init()`
Инициализирует криптографическую библиотеку (libsodium). **Должна быть вызвана один раз** при запуске приложения.
- **Возвращает:** `0` в случае успеха, `-1` при ошибке.

### `static KeyPair generate_kx_keypair()`
Генерирует пару ключей (X25519) для обмена ключами по алгоритму Диффи-Хеллмана (ECDH).

### `static KeyPair generate_sign_keypair()`
Генерирует пару ключей (Ed25519) для создания и проверки цифровых подписей.

### `static Signature sign(const byte_vector& message, const PrivateKey& private_key)`
Создает цифровую подпись для сообщения.
- **Выбрасывает:** `InvalidArgument`, если размер приватного ключа некорректен.

### `static bool verify(const Signature& signature, const byte_vector& message, const PublicKey& public_key)`
Проверяет цифровую подпись.
- **Возвращает:** `true`, если подпись верна, иначе `false`.

### `struct SessionKeys`
Структура для хранения сессионных ключей, полученных после рукопожатия.
- `byte_vector rx`: Ключ для расшифровки входящих сообщений.
- `byte_vector tx`: Ключ для зашифровки исходящих сообщений.

### `static SessionKeys client_compute_session_keys(...)`
**Для клиента.** Вычисляет сессионные ключи на основе своей эфемерной пары ключей и публичного эфемерного ключа сервера.
- **Выбрасывает:** `InvalidArgument` при неверных размерах ключей, `RuntimeError` при сбое вычислений.

### `static SessionKeys server_compute_session_keys(...)`
**Для сервера.** Вычисляет сессионные ключи на основе своей эфемерной пары ключей и публичного эфемерного ключа клиента.
- **Выбрасывает:** `InvalidArgument` при неверных размерах ключей, `RuntimeError` при сбое вычислений.

### `static EncryptedPacket encrypt(const Payload& payload, uint64_t counter, const byte_vector& key)`
Шифрует `Payload` с использованием ChaCha20-Poly1305.
- `counter`: Счётчик сообщений для защиты от replay-атак. Он включается в пакет как ассоциированные данные (не шифруется, но защищается аутентификационным тегом).
- **Возвращает:** `EncryptedPacket` в формате `[Nonce][Counter][Ciphertext+Tag]`.
- **Выбрасывает:** `InvalidArgument` при неверном размере ключа.

### `struct DecryptedResult`
Результат успешной расшифровки.
- `Payload payload`: Расшифрованная полезная нагрузка.
- `uint64_t counter`: Счётчик, извлечённый из пакета.

### `static DecryptedResult decrypt(const EncryptedPacket& packet, const byte_vector& key)`
Расшифровывает пакет. Проверяет аутентификационный тег.
- **Возвращает:** `DecryptedResult` в случае успеха.
- **Выбрасывает:** `InvalidArgument` при неверном размере ключа, `RuntimeError` при сбое расшифровки (неверный тег, поврежденные данные).

---

## `session.hpp`

Основной класс для управления состоянием сессии.

### `enum class Role`
Определяет роль текущей стороны.
- `CLIENT`: Сессия является клиентом.
- `SERVER`: Сессия является сервером.

### `class ObscuraProto::Session`
Управляет состоянием сессии, включая рукопожатие и обмен данными.

#### `Session(Role role, KeyPair server_sign_key)`
Конструктор сессии.
- `role`: Роль этой сессии (`CLIENT` или `SERVER`).
- `server_sign_key`:
    - Для **сервера**: полная долгосрочная пара ключей подписи (публичный и приватный).
    - Для **клиента**: пара, содержащая только публичный ключ подписи сервера.

### Структуры для рукопожатия

- `struct ClientHello`: Сообщение от клиента к серверу. Содержит список поддерживаемых версий и эфемерный публичный ключ клиента.
- `struct ServerHello`: Сообщение от сервера к клиенту. Содержит выбранную версию, эфемерный публичный ключ сервера и его подпись.

### Методы рукопожатия

#### `ClientHello client_initiate_handshake()`
**Для клиента.** Инициирует рукопожатие. Генерирует эфемерную пару ключей и создает `ClientHello`.
- **Выбрасывает:** `LogicError`, если вызывается на стороне сервера.

#### `ServerHello server_respond_to_handshake(const ClientHello& client_hello)`
**Для сервера.** Обрабатывает `ClientHello`, генерирует свою эфемерную пару, вычисляет сессионные ключи и возвращает `ServerHello`.
- **Выбрасывает:** `LogicError`, если вызывается на стороне клиента; `RuntimeError` при несовместимости версий или сбое крипто-операций.

#### `void client_finalize_handshake(const ServerHello& server_hello)`
**Для клиента.** Завершает рукопожатие. Проверяет подпись сервера и вычисляет сессионные ключи.
- **Выбрасывает:** `LogicError`, если вызывается до `client_initiate_handshake`; `RuntimeError` при неверной подписи или сбое крипто-операций.

### Методы обмена данными

#### `EncryptedPacket encrypt_payload(const Payload& payload)`
Шифрует `Payload`. Автоматически увеличивает счётчик отправленных сообщений.
- **Выбрасывает:** `LogicError`, если рукопожатие не завершено.

#### `Payload decrypt_packet(const EncryptedPacket& packet)`
Расшифровывает `EncryptedPacket`. Проверяет счётчик сообщений для защиты от replay-атак.
- **Возвращает:** `Payload` в случае успеха.
- **Выбрасывает:** `LogicError`, если рукопожатие не завершено; `RuntimeError` при сбое расшифровки или обнаружении replay-атаки.

### Прочие методы

#### `bool is_handshake_complete() const`
Проверяет, было ли успешно завершено рукопожатие.
- **Возвращает:** `true`, если сессия готова к обмену данными.
