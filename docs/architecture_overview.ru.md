# Обзор архитектуры ObscuraProto

Этот документ описывает архитектуру и компоненты библиотеки `ObscuraProto`.

## Общая картина
`ObscuraProto` — это библиотека для установления защищённого канала связи между клиентом и сервером. Протокол выполняет "рукопожатие" (handshake) для генерации общих сессионных ключей, а затем использует их для шифрования всего трафика. Архитектура похожа на упрощённую версию TLS, нацеленную на легковесность и простоту интеграции.

---

### 1. `keys.hpp`
Это базовый файл, который определяет простые структуры данных для хранения криптографических ключей и подписей.

- **`PublicKey` / `PrivateKey`**: Структуры для публичного и приватного ключей. Внутри — просто массив байт (`std::vector<uint8_t>`).
- **`KeyPair`**: Объединяет публичный и приватный ключи в одну пару.
- **`Signature`**: Структура для хранения цифровой подписи.

**Назначение:** Создаёт "контейнеры" для ключей и подписей, чтобы их было удобно передавать внутри программы.

---

### 2. `version.hpp`
Этот файл отвечает за версионирование протокола.

- **`Version`**: Тип для номера версии (`uint16_t`).
- **`Versions::V1_0`**: Константа для версии 1.0.
- **`SUPPORTED_VERSIONS`**: Список версий, которые поддерживает библиотека.

**Назначение:** Позволяет клиенту и серверу при соединении убедиться, что они "говорят на одном языке" (одной и той же версии протокола).

---

### 3. `packet.hpp`
Здесь описывается структура пакетов данных, которыми обмениваются стороны *до* шифрования.

- **`byte_vector`**: Псевдоним для `std::vector<uint8_t>`, используется для работы с сырыми бинарными данными.
- **`EncryptedPacket`**: Псевдоним для `byte_vector`. Это зашифрованный пакет данных, его содержимое непрозрачно.
- **`Payload`**: Ключевой класс, представляющий "полезную нагрузку" — команды и данные в незашифрованном виде.
    - **`op_code`**: "Код операции". `uint16_t`, которое обозначает тип команды (например, 1 - "авторизоваться", 2 - "отправить сообщение").
    - **`parameters`**: Данные, относящиеся к этой команде.
    - **`add_param(...)`**: Методы для добавления параметров. Используется сериализация с префиксом длины (перед каждым параметром записывается его длина), что позволяет легко разделять их при чтении.
    - **`serialize()` / `deserialize()`**: Функции, которые превращают объект `Payload` в единый массив байт и обратно. `deserialize()` бросает исключение `ObscuraProto::RuntimeError`, если данные повреждены.
    - **`ParamParser`**: Вспомогательный класс, который помогает удобно извлекать параметры по одному из полученного `Payload`.

**Назначение:** `Payload` — это "конверт", в который вы кладёте команду (`op_code`) и её данные (`parameters`), прежде чем запечатать его (зашифровать).

---

### 4. `errors.hpp`
Этот файл определяет пользовательские типы исключений, используемые в библиотеке.

- **`Exception`**: Базовый класс исключений, наследуется от `std::exception`.
- **`RuntimeError`**: Ошибка времени выполнения общего назначения, используется для таких проблем, как сбой расшифровки, неверные подписи или ошибки рукопожатия.
- **`LogicError`**: Ошибка, указывающая на неверное использование библиотеки (например, вызов `encrypt` до завершения рукопожатия).

**Назначение:** Предоставляет структурированный способ обработки ошибок, позволяя пользователю перехватывать определённые типы исключений.

---

### 5. `crypto.hpp`
Это "мозг" всей системы шифрования. Все криптографические операции реализованы как статические методы в классе `Crypto` (вероятно, с использованием `libhydrogen`).

- **`init()`**: Инициализирует крипто-библиотеку. Должна быть вызвана один раз при старте программы.
- **`generate_kx_keypair()` / `generate_sign_keypair()`**: Генерируют пары ключей. `kx` (Key Exchange) — для обмена ключами, `sign` — для цифровых подписей.
- **`sign()` / `verify()`**: Создают и проверяют цифровые подписи для аутентификации и целостности сообщений.
- **`SessionKeys`**: Структура для хранения двух сессионных ключей (`rx` для приёма, `tx` для отправки), которые генерируются во время рукопожатия.
- **`client_compute_session_keys()` / `server_compute_session_keys()`**: Реализуют обмен ключами по алгоритму Диффи-Хеллмана (ECDH) для выработки общих секретных ключей.
- **`encrypt()`**: Шифрует `Payload` с помощью алгоритма ChaCha20-Poly1305. Принимает счётчик сообщений, который включается в пакет для защиты от атак повторного воспроизведения.
- **`decrypt()`**: Расшифровывает пакет. Возвращает структуру `DecryptedResult`, содержащую `Payload` и `счётчик` из пакета. Бросает исключение `ObscuraProto::RuntimeError` в случае сбоя.

**Назначение:** Предоставляет все необходимые инструменты для генерации ключей, установки защищённого соединения и шифрования данных.

---

### 6. `session.hpp`
Этот файл объединяет всё в единую логику управления сессией.

- **`Role`**: Перечисление, которое указывает, кто использует сессию — `CLIENT` или `SERVER`.
- **`Session`**: Главный класс, управляющий состоянием соединения.
    - **`Session(Role role, ...)`**: Конструктор инициализирует сессию. Для сервера требуется его долгосрочный ключ подписи. Для клиента — публичный ключ подписи сервера.
    - **`client_initiate_handshake()`**: **Для клиента.** Запускает рукопожатие, создавая сообщение `ClientHello`.
    - **`server_respond_to_handshake(...)`**: **Для сервера.** Принимает `ClientHello`, проверяет его и генерирует ответ `ServerHello`. Бросает исключение при ошибке.
    - **`client_finalize_handshake(...)`**: **Для клиента.** Принимает `ServerHello`, проверяет его и вычисляет общие сессионные ключи. Бросает исключение при ошибке.
    - **`encrypt_payload(...)` / `decrypt_packet(...)`**: Основные функции для обмена данными после рукопожатия. Управляют шифрованием и счётчиками сообщений для защиты от атак повторного воспроизведения.
    - **`is_handshake_complete()`**: Позволяет проверить, установлен ли защищённый канал.

### Жизненный цикл сессии

1.  **Настройка**: Клиент и сервер создают объект `Session`, указывая свою роль и предоставляя необходимые ключи подписи.
2.  **Рукопожатие (3-этапное)**:
    *   Клиент вызывает `client_initiate_handshake()` и отправляет результат (`ClientHello`) серверу.
    *   Сервер получает `ClientHello` и вызывает `server_respond_to_handshake()`. Он отправляет результат (`ServerHello`) обратно клиенту.
    *   Клиент получает `ServerHello` и вызывает `client_finalize_handshake()`.
    *   **Результат**: У обеих сторон теперь есть общие сессионные ключи, и канал связи считается безопасным.
3.  **Обмен данными**:
    *   Отправитель создаёт `Payload` с командой и данными.
    *   Вызывает `session.encrypt_payload()` для шифрования.
    *   Отправляет зашифрованный пакет по сети.
    *   Получатель принимает пакет и вызывает `session.decrypt_packet()`, чтобы получить исходный `Payload`.
    *   Анализирует `Payload` и выполняет запрошенную команду.
